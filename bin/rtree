#!/bin/bash

set -euo pipefail

# check environment
if [ -z "${RTREE_ROOT:-}" ]; then
  echo "FATAL: \$RTREE_ROOT not set"
  exit 1
fi
INDEX_DIR="${HOME}/.rtree"
mkdir -p "${INDEX_DIR}"

# prepare URL resolver repo
RESOLVE_REPO_DIR=${XDG_RUNTIME_DIR}/resolve-git-urls
if [ ! -d "${RESOLVE_REPO_DIR}" ]; then
  mkdir -p "${RESOLVE_REPO_DIR}"
  git -C "${RESOLVE_REPO_DIR}" init --bare >/dev/null
fi

usage_and_exit() {
  exec >&2
  echo "Usage:"
  echo "  $0 get <url>"
  echo "  $0 [index|repos|remotes]"
  echo "  $0 import <path>"
  echo "  $0 each <command>"
  exit 1
}

relpath() {
    # use like: relpath $target $source
    if hash python2 &>/dev/null; then
        python2 -c "import sys, os.path; print os.path.relpath(sys.argv[1], sys.argv[2]) " "$@"
    else
        python3 -c "import sys, os.path; print(os.path.relpath(sys.argv[1], sys.argv[2]))" "$@"
    fi
}

resolve_url() {
  local INPUT_URL="$1"

  git -C "${RESOLVE_REPO_DIR}" remote add $$ "${INPUT_URL}" >/dev/null
  ACTUAL_URL="$(git -C "${RESOLVE_REPO_DIR}" remote get-url $$)"
  git -C "${RESOLVE_REPO_DIR}" remote rm $$ >/dev/null

  # remove protocol part to obtain a checkout path
  local SCRIPT
  set +e
  read -r -d '' SCRIPT <<'EOF'
    ($_) = @ARGV;
    if (/@/) { say s{^.+?@(.+?)[:/](.+)$}{$1/$2}r }
    else     { say s{^\w+:/+}{}r }
EOF
  set -e
  perl -E "${SCRIPT}" "${ACTUAL_URL}"
}

index_add() {
  local REMOTE_URL="$1" REPO_PATH="$2"
  echo "${REPO_PATH}" > "${INDEX_DIR}/$(echo -n "${REMOTE_URL}" | base64 -w 0)"
}

index_add_directory() {
  local DIR="$1"
  REPO_PATH="$(relpath "${DIR}" "${RTREE_ROOT}/src")"
  git -C "${DIR}" config -l | grep -E '^remote.\w+.url' | cut -d= -f2- | while read REMOTE; do
    index_add "${REMOTE}" "${REPO_PATH}"
  done
}

list_repos() {
  find "${RTREE_ROOT}/src" -exec test -d {}/.git \; -print -prune
}

command_get() {
  local REMOTE_URL="$1"

  # if this remote is indexed, report the associated repository
  local INDEX_FILE="${INDEX_DIR}/$(echo -n "${REMOTE_URL}" | base64 -w 0)"
  if [ -f "${INDEX_FILE}" ]; then
    echo -n "${RTREE_ROOT}/src/"
    cat "${INDEX_FILE}"
    return 0
  fi

  # not yet indexed - determine local path from remote URL
  local REPO_PATH="$(resolve_url "${REMOTE_URL}")"
  local FULL_PATH="${RTREE_ROOT}/src/${REPO_PATH}"

  # clone repository if missing
  if [ ! -d "${FULL_PATH}/.git" ]; then
    git clone -- "${REMOTE_URL}" "${FULL_PATH}"
  fi
  index_add "${REMOTE_URL}" "${REPO_PATH}"

  # report path
  echo "${FULL_PATH}"
}

command_import() {
  local ORIG_PATH="$1"
  local REMOTE_URL="$(git -C "${ORIG_PATH}" config remote.origin.url)"
  if [ -z "${REMOTE_URL}" ]; then
    echo "ERROR: no remote \"origin\" found in given repository" >&2
    return 1
  fi

  # check if this remote is already checked out in the rtree
  local INDEX_FILE="${INDEX_DIR}/$(echo -n "${REMOTE_URL}" | base64 -w 0)"
  if [ -f "${INDEX_FILE}" ]; then
    echo "ERROR: not overwriting existing checkout of \"${REMOTE_URL}\" at \"$(cat ${INDEX_FILE})\"" >&2
    return 1
  fi

  # determine local path from remote URL
  local REPO_PATH="$(resolve_url "${REMOTE_URL}")"
  local FULL_PATH="${RTREE_ROOT}/src/${REPO_PATH}"
  if [ -d "${FULL_PATH}" ]; then
    echo "ERROR: directory \"$(cat ${INDEX_FILE})\" already exists (you can try to \`rtree index\`)" >&2
    return 1
  fi

  # import repository into rtree
  mkdir -p "$(dirname "${FULL_PATH}")"
  mv "${ORIG_PATH}" "${FULL_PATH}"
  index_add_directory "${FULL_PATH}"

  # make a symbolic link from old to new location to ease the transition
  ln -sT "${FULL_PATH}" "${ORIG_PATH%/}"
}

command_remotes() {
  find "${INDEX_DIR}" -maxdepth 1 -type f | while read INDEX_FILE; do
    echo "$(basename "${INDEX_FILE}" | base64 -d)" # echo appends "\n"
  done | sort
}

command_repos() {
  find "${INDEX_DIR}" -maxdepth 1 -type f -exec cat {} + | sort -u
}

command_index() {
  # find new index entries (the particular way in which find(1) is invoked here
  # ensures that submodules are ignored)
  list_repos | while read DIR; do
    index_add_directory "${DIR}"
  done

  # handle old index entries
  for INDEX_FILE in $(find "${INDEX_DIR}" -maxdepth 1 -type f); do
    REMOTE_URL="$(basename "${INDEX_FILE}" | base64 -d)"
    REPO_PATH="$(cat "${INDEX_FILE}")"
    FULL_PATH="${RTREE_ROOT}/src/${REPO_PATH}"
    if [ ! -d "${FULL_PATH}/.git" ]; then
      # handle index entries without repository
      echo "repository ${REPO_PATH} has been deleted"
      echo -n ">> (r)estore from ${REMOTE_URL}, (d)elete from index, or (s)kip? "
      while true; do
        read -n1 ANSWER; echo
        case "${ANSWER}" in
          r|R) git clone -- "${REMOTE_URL}" "${FULL_PATH}" ;;
          d|D) rm -- "${INDEX_FILE}"                       ;;
          s|S)                                             ;;
          *)
            echo -n "Please type 'r', 'd' or 's': "
            continue
            ;;
        esac
        break
      done
    fi
  done
}

command_each() {
  list_repos | while read DIR; do (
    echo -e "\e[1;36m>> \e[0;36m${DIR}\e[0m"
    cd "${DIR}"
    set +e
    "$@"
    STATUS=$?
    if [ $STATUS -gt 0 ]; then
      echo -e "\e[1;31m!! Exit status $STATUS\e[0m"
    fi
  ); done
}

# read command line
[ $# -gt 0 ] || usage_and_exit
case "$1" in
  get)
    [ $# -eq 2 ] || usage_and_exit
    command_get "$2"
    ;;
  import)
    [ $# -eq 2 ] || usage_and_exit
    command_import "$2"
    ;;
  index)
    [ $# -eq 1 ] || usage_and_exit
    command_index
    ;;
  remotes)
    [ $# -eq 1 ] || usage_and_exit
    command_remotes
    ;;
  repos)
    [ $# -eq 1 ] || usage_and_exit
    command_repos
    ;;
  each)
    [ $# -gt 1 ] || usage_and_exit
    shift # remove leading "each" from $@
    command_each "$@"
    ;;
  *)
    usage_and_exit
    ;;
esac
