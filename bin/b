#!/usr/bin/perl
use strict; use warnings;

# Build.pm is in the same directory as this file (modulo symlinks!)
BEGIN {
    use File::Spec;
    use lib (File::Spec->splitpath(readlink $0))[1];
}

use Build;
use Cwd;

sub cwd_to_source {
    return new Build::Source(Cwd::cwd());
}
sub cwd_to_bucket {
    my $cwd = Cwd::cwd();

    # TODO: code duplication with Build::Source::new()
    my @bucket_paths = <$Build::Config::bucket_dir/*>;
    for my $bucket_name (@bucket_paths) {
        next unless -d $bucket_name;
        if (startswith($cwd, $bucket_name)) {
            # we are inside this bucket
            $bucket_name =~ s{^.*/}{};
            return new Build::Bucket($bucket_name);
        }
    }

    # we are not in any bucket -> assume this is a source tree
    return cwd_to_source()->bucket();
}

if (@ARGV && $ARGV[0]) {
    if (startswith('configure', $ARGV[0])) {
        cwd_to_source()->force_configure(@ARGV[1..$#ARGV]) or exit 1;
    }
    elsif (startswith('install', $ARGV[0])) {
        cwd_to_source()->install() or exit 1;
    }
    elsif (startswith('make', $ARGV[0])) {
        cwd_to_source()->build(@ARGV[1..$#ARGV]) or exit 1;
    }
    elsif (startswith('run', $ARGV[0])) {
        exit 1 unless cwd_to_bucket()->run_command(@ARGV[1..$#ARGV]) == 0;
    }
    else {
        cwd_to_source()->build(@ARGV) or exit 1;
    }
}
else {
    cwd_to_source()->update() or exit 1;
}

# Returns true if $input is not empty and $word starts with $input.
sub startswith {
    my ($word, $input) = @_;
    return 0 unless $input;
    return substr($word, 0, length($input)) eq $input;
}
