export EDITOR=vim
export PAGER="less -R"

# set colors for man(1)
export LESS_TERMCAP_mb=$'\e[01;31m'       # start of blinking text
export LESS_TERMCAP_md=$'\e[01;38;5;74m'  # start of bold text
export LESS_TERMCAP_me=$'\e[0m'           # end of blinking/bold text
export LESS_TERMCAP_so=$'\e[30;48;5;246m' # start of statusline text
export LESS_TERMCAP_se=$'\e[0m'           # end of statusline text
export LESS_TERMCAP_us=$'\e[04;38;5;146m' # start of underlined text
export LESS_TERMCAP_ue=$'\e[0m'           # end of underlined text

if [ -f /proc/cpuinfo ]; then
	export NUMCPUCORES="$(nproc)"
fi

if [ -z "$LOCALPROFILEREAD" ]; then
	export PATH="$HOME/bin:/x/bin:$PATH"
	export BUILD_ROOT=/x/build
	export GOPATH=/x
	export GOBIN=/x/bin

	if [ -d $HOME/perl5 ]; then
		eval $(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
	fi
	if [ -d $HOME/.rbenv ]; then
		export PATH="$HOME/.rbenv/bin:$PATH"
	fi
fi

# aliases
alias less='less -R'            # recognise color characters
if hash mpc &>/dev/null; then
	alias m=mpc
	alias mi='mpc idle player; mpc'
fi
if hash ncmpcpp &>/dev/null; then
	alias ncmpc=ncmpcpp
fi
if [ "$(uname)" = "Linux" ]; then
	alias ls='ls --color=auto'
fi
if [ -f /usr/bin/steam ]; then
	alias steam="nice -n10 /usr/bin/steam"
fi
if grep ID=arch /etc/os-release &>/dev/null; then
	alias p=pacman-wrapper
fi
if hash pwget &>/dev/null; then
	pwcopy() {
		pwget "$@" | xsel -bi
	}
fi
if hash units &>/dev/null; then
	alias units="units --verbose"
fi
cg() {
	local REPO_PATH="$(rtree get "$1")"
	[ $? -eq 0 ] && cd "${REPO_PATH}"
}

if hash rg &>/dev/null; then
	rg() {
		# force ripgrep output to look like on a tty, even when sent to less(1)
		env rg --heading --color always --line-number "$@"
	}
fi

forever() {
	while true; do
		"$@"
		sleep 0.1 # to make ^C work correctly if "$@" does not handle it correctly
	done
}

if hash mpv &>/dev/null; then
	mpv() {
		if [ $# -eq 0 ]; then
			env mpv "$(xsel -b)"
		else
			env mpv "$@"
		fi
	}
fi

if hash youtube-dl &>/dev/null; then
	youtube-dl() {
		if [ $# -eq 0 ]; then
			env youtube-dl -f best "$(xsel -b)"
		else
			env youtube-dl "$@"
		fi
	}
fi

# for OpenStack
if [ -f "$HOME/.local/bin/openstack" ]; then
	cloud_is() {
		unset $(env | grep '^OS_' | cut -d= -f1) CURRENT_OS_CLOUD
		eval "$(/x/bin/cloud "$@"; echo "EXIT_CODE=$?")"
		if [ "$EXIT_CODE" = 0 ]; then
			env | grep '^OS_' | sed '/^OS_PASSWORD=/s/=.*/=<hidden>/' | sort
			if [ -z "$OS_PASSWORD" ]; then
				echo -n "OS_PASSWORD="
				read -s OS_PASSWORD && export OS_PASSWORD
				if [ -n "$OS_PASSWORD" ]; then
					echo "<hidden>"
				else
					echo "<not set>"
				fi
			fi
		fi
	}
fi

# for Ruby
if [ -d $HOME/.rbenv ]; then
	eval "$(rbenv init -)"
fi
if hash foreman &>/dev/null; then
	foreman() {
		[ -f .procfile ] && env foreman "$@" -f .procfile || env foreman "$@"
	}
fi

if hash kubectl &>/dev/null; then
	kc() {
		case $# in
			1)
				kubectl config use-context "$1"
				echo "" > ~/.kubectl-namespace
				;;
			2)
				kubectl config use-context "$1"
				echo "$2" > ~/.kubectl-namespace
				;;
			*)
				echo "usage: kc <context> [namespace]" >&2
				return 1
				;;
		esac
	}

	kn() {
		case $# in
			0)
				echo "" > ~/.kubectl-namespace
				;;
			1)
				echo "$1" > ~/.kubectl-namespace
				;;
			*)
				echo "usage: kn [namespace]" >&2
				return 1
				;;
		esac
	}

	k() {
		local KUBECTL
		local KUBECTL_NAMESPACE="$(cat ~/.kubectl-namespace)"
		if [ "${KUBECTL_NAMESPACE}" != "" ]; then
			KUBECTL=(kubectl --namespace="$KUBECTL_NAMESPACE")
		else
			KUBECTL=kubectl
		fi

		case "$1" in
		sh)
			shift
			${KUBECTL} exec -ti "$@" -- env COLUMNS=$COLUMNS LINES=$LINES TERM=$TERM /bin/sh
			;;
		bash)
			shift
			${KUBECTL} exec -ti "$@" -- env COLUMNS=$COLUMNS LINES=$LINES TERM=$TERM /bin/bash
			;;
		yaml)
			shift
			${KUBECTL} get "$@" -o yaml
			;;
		*)
			${KUBECTL} "$@"
			;;
		esac
	}

	if hash helm &>/dev/null; then
		# Synopsis: h <upgrade|diff> [chart-directory] [options]
		#
		# Call `helm upgrade` or `helm diff` on the chart in that directory, using the appropriate
		# values.yaml from $HELM_SECRETS_REPO. If no directory is given, use the working directory.
		# Any additional options are passed on to "helm upgrade".
		h() {
			(
				local COMMAND="$1"
				shift

				case "${1:-empty}" in
					-*|empty)
						;;
					*)
						cd "$1"
						shift
						;;
				esac
				if [ ! -f Chart.yaml ]; then
					echo "Chart.yaml: file not found" >&2
					return 1
				fi
				if [ -z "${HELM_SECRETS_REPO}" ]; then
					echo "\$HELM_SECRETS_REPO not set!" >&2
					return 1
				fi

				git -C "${HELM_SECRETS_REPO}" pull | grep -v 'master is up to date'

				CHART_NAME="$(awk '/name:/{print$2}' Chart.yaml)"
				CONTEXT_NAME="$(kubectl config current-context)"
				VALUES_FILE="$(find "${HELM_SECRETS_REPO}/${CONTEXT_NAME}/values" -name "${CHART_NAME}.yaml" | head -n1)"
				if [ ! -f "${VALUES_FILE}" ]; then
					echo "no values.yaml found for ${CHART_NAME} in ${CONTEXT_NAME}" >&2
					return 1
				fi
				GLOBALS_FILE="${HELM_SECRETS_REPO}/${CONTEXT_NAME}/values/globals.yaml"
				if [ ! -f "${GLOBALS_FILE}" ]; then
					echo "no globals.yaml found in ${CONTEXT_NAME}" >&2
					return 1
				fi

				if [ "${CONTEXT_NAME}" != staging -a "${COMMAND}" = upgrade -a "${I_KNOW_THIS_IS_PROD:-}" != yes ]; then
					echo "Not upgrading a productive region without I_KNOW_THIS_IS_PROD=yes." >&2
					return 1
				fi

				EXTRA_ARGS=""
				if [ "${COMMAND}" = upgrade ]; then
					EXTRA_ARGS="--reset-values"
				fi
				helm "${COMMAND}" "${CHART_NAME}" --values "${GLOBALS_FILE}" --values "${VALUES_FILE}" ${EXTRA_ARGS} "$@" .
			)
		}
	fi
fi

# this must always be at the end
export LOCALPROFILEREAD="yes"
