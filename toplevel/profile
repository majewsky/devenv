rm -rf $HOME/.adobe

export EDITOR=vim
export PAGER="less -R"
if [ -f /proc/cpuinfo ]; then
	export NUMCPUCORES="$(nproc)"
fi

if [ -z "$LOCALPROFILEREAD" ]; then
	# add home directory path
	if [ -d "$HOME/bin" ]; then
		export PATH="$HOME/bin:$PATH"
	fi

	export BUILD_ROOT=/x/build
	export RTREE_ROOT=/x
	# for Golang
	export GOPATH=$RTREE_ROOT
	export GOBIN=$GOPATH/bin
	export PATH="$PATH:$GOBIN"

	if [ -d $HOME/perl5 ]; then
		eval $(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
	fi
	if [ -d $HOME/.rbenv ]; then
		export PATH="$HOME/.rbenv/bin:$PATH"
	fi
fi

# aliases
alias less='less -R'            # recognise color characters
alias m=mpc
alias mi='mpc idle player; mpc'
which ncmpc &>/dev/null || alias ncmpc=ncmpcpp
if [ "$(uname)" = "Linux" ]; then
	alias ls='ls --color=auto'
fi
if [ -f /usr/bin/steam ]; then
	alias steam="nice -n10 /usr/bin/steam"
fi
if grep ID=arch /etc/os-release &>/dev/null; then
	alias p=pacman-wrapper
fi
alias rpe="perl -MData::Dump=pp -Mstrict -Mwarnings -le"
if which pwget &>/dev/null; then
	pwcopy() {
		pwget "$@" | xsel -bi
	}
fi
if which units &>/dev/null; then
	alias units="units --verbose"
fi
cg() {
	local REPO_PATH="$(rtree get "$1")"
	[ $? -eq 0 ] && cd "${REPO_PATH}"
}

if which rg &>/dev/null; then
	rg() {
		# force ripgrep output to look like on a tty, even when sent to less(1)
		env rg --heading --color always --line-number "$@"
	}
fi

# for OpenStack
if [ -f "$HOME/.local/bin/openstack" ]; then
	cloud_is() {
		eval "$(/x/src/github.com/majewsky/devenv/env_for_cloud.rb $1)"
		env | grep '^OS_' | sed '/^OS_PASSWORD=/s/=.*/=<hidden>/' | sort
		if [ -z "$OS_PASSWORD" ]; then
			echo -n "OS_PASSWORD="
			read -s OS_PASSWORD && export OS_PASSWORD
			if [ -n "$OS_PASSWORD" ]; then
				echo "<hidden>"
			else
				echo "<not set>"
			fi
		fi
	}
fi

# for Ruby
if [ -d $HOME/.rbenv ]; then
	eval "$(rbenv init -)"
fi
if hash foreman &>/dev/null; then
	foreman() {
		[ -f .procfile ] && env foreman "$@" -f .procfile || env foreman "$@"
	}
fi

# this must always be at the end
export LOCALPROFILEREAD="yes"

if hash docker &>/dev/null; then
	docker() {
		if [ $# -eq 0 ]; then
			env docker "$@"
		fi

		case "$1" in
			build)
				shift
				env docker build --build-arg https_proxy=$HTTP_PROXY --build-arg http_proxy=$HTTP_PROXY --build-arg HTTP_PROXY=$HTTP_PROXY --build-arg HTTPS_PROXY=$HTTP_PROXY --build-arg NO_PROXY=$NO_PROXY --build-arg no_proxy=$NO_PROXY "$@"
				;;
			*)
				env docker "$@"
				;;
		esac
	}
fi

if hash kubectl &>/dev/null; then
	export HAS_KUBECTL=true

	kc() {
		case $# in
			1)
				kubectl config use-context "$1"
				echo "" > ~/.kubectl-namespace
				;;
			2)
				kubectl config use-context "$1"
				echo "$2" > ~/.kubectl-namespace
				;;
			*)
				echo "usage: kc <context> [namespace]" >&2
				return 1
				;;
		esac
	}

	kn() {
		case $# in
			0)
				echo "" > ~/.kubectl-namespace
				;;
			1)
				echo "$1" > ~/.kubectl-namespace
				;;
			*)
				echo "usage: kn [namespace]" >&2
				return 1
				;;
		esac
	}

	k() {
		local KUBECTL
		local KUBECTL_NAMESPACE="$(cat ~/.kubectl-namespace)"
		if [ "${KUBECTL_NAMESPACE}" != "" ]; then
			KUBECTL=(kubectl --namespace="$KUBECTL_NAMESPACE")
		else
			KUBECTL=kubectl
		fi

		# if there is a jumpserver involved, it is defined in the .ssh/config
		# as "Host ${CONTEXT_NAME}" and it includes a LocalForward directive
		# that allows access to a HTTP proxy which we can use to talk to the
		# k8s apiserver
		local CONTEXT_NAME="$(kubectl config current-context)"
		local PROXY_PORT="$(sed -n "/^Host ${CONTEXT_NAME}/,/^Host/{/LocalForward/p}" "${HOME}/.ssh/config" | awk '{print$2}')"
		if [ -n "${PROXY_PORT}" ]; then
			KUBECTL=(env -u no_proxy -u NO_PROXY "https_proxy=http://localhost:${PROXY_PORT}" "HTTPS_PROXY=http://localhost:${PROXY_PORT}" ${KUBECTL})
		fi

		case "$1" in
		sh)
			shift
			${KUBECTL} exec -ti "$@" -- env COLUMNS=$COLUMNS LINES=$LINES TERM=$TERM /bin/sh
			;;
		bash)
			shift
			${KUBECTL} exec -ti "$@" -- env COLUMNS=$COLUMNS LINES=$LINES TERM=$TERM /bin/bash
			;;
		yaml)
			shift
			${KUBECTL} get "$@" -o yaml
			;;
		*)
			${KUBECTL} "$@"
			;;
		esac
	}

	if hash helm &>/dev/null; then
		h() {
			# if there is a jumpserver involved, it is defined in the .ssh/config
			# as "Host ${CONTEXT_NAME}" and it includes a LocalForward directive
			# that allows access to a HTTP proxy which we can use to talk to the
			# k8s apiserver
			local CONTEXT_NAME="$(kubectl config current-context)"
			local PROXY_PORT="$(sed -n "/^Host ${CONTEXT_NAME}/,/^Host/{/LocalForward/p}" "${HOME}/.ssh/config" | awk '{print$2}')"
			if [ -n "${PROXY_PORT}" ]; then
				env -u no_proxy -u NO_PROXY "https_proxy=http://localhost:${PROXY_PORT}" "HTTPS_PROXY=http://localhost:${PROXY_PORT}" helm "$@"
			else
				helm "$@"
			fi
		}

		# Synopsis: hu [chart-directory] [options]
		#
		# Call `helm upgrade` on the chart in that directory, using the appropriate
		# values.yaml from $HELM_SECRETS_REPO. If no directory is given, use the working directory.
		# Any additional options are passed on to "helm upgrade".
		hu() {
			(
				case "${1:-empty}" in
					-*|empty)
						;;
					*)
						cd "$1"
						shift
						;;
				esac
				if [ ! -f Chart.yaml ]; then
					echo "Chart.yaml: file not found" >&2
					return 1
				fi
				if [ -z "${HELM_SECRETS_REPO}" ]; then
					echo "\$HELM_SECRETS_REPO not set!" >&2
				fi

				git -C "${HELM_SECRETS_REPO}" pull | grep -v 'master is up to date'

				CHART_NAME="$(awk '/name:/{print$2}' Chart.yaml)"
				CONTEXT_NAME="$(kubectl config current-context)"
				VALUES_FILE="$(find "${HELM_SECRETS_REPO}/${CONTEXT_NAME}/values" -name "${CHART_NAME}.yaml" | head -n1)"
				if [ ! -f "${VALUES_FILE}" ]; then
					echo "no values.yaml found for ${CHART_NAME} in ${CONTEXT_NAME}" >&2
					return 1
				fi

				echo "    Chart: ${CHART_NAME}"
				echo "   Region: ${CONTEXT_NAME}"
				echo "   Values: ${VALUES_FILE}"
				echo -n ">> Upgrade chart? [Y/n] "
				read ANSWER
				if [[ "${ANSWER}" != *[nN]* ]]; then
					h upgrade "${CHART_NAME}" --values "${VALUES_FILE}" --reset-values "$@" .
				fi
			)
		}

		# Synopsis: hd [chart-directory] [options]
		#
		# Like `hu`, but calls `helm diff` instead of `helm upgrade`.
		hd() {
			(
				case "${1:-empty}" in
					-*|empty)
						;;
					*)
						cd "$1"
						shift
						;;
				esac
				if [ ! -f Chart.yaml ]; then
					echo "Chart.yaml: file not found" >&2
					return 1
				fi
				if [ -z "${HELM_SECRETS_REPO}" ]; then
					echo "\$HELM_SECRETS_REPO not set!" >&2
				fi

				git -C "${HELM_SECRETS_REPO}" pull | grep -v 'master is up to date'

				CHART_NAME="$(awk '/name:/{print$2}' Chart.yaml)"
				CONTEXT_NAME="$(kubectl config current-context)"
				VALUES_FILE="$(find "${HELM_SECRETS_REPO}/${CONTEXT_NAME}/values" -name "${CHART_NAME}.yaml" | head -n1)"
				if [ ! -f "${VALUES_FILE}" ]; then
					echo "no values.yaml found for ${CHART_NAME} in ${CONTEXT_NAME}" >&2
					return 1
				fi

				h diff "${CHART_NAME}" --values "${VALUES_FILE}" "$@" .
			)
		}
	fi
fi
