export EDITOR=vim
export PAGER="less -R"

# set colors for man(1)
export LESS_TERMCAP_mb=$'\e[01;31m'       # start of blinking text
export LESS_TERMCAP_md=$'\e[01;38;5;74m'  # start of bold text
export LESS_TERMCAP_me=$'\e[0m'           # end of blinking/bold text
export LESS_TERMCAP_so=$'\e[30;48;5;246m' # start of statusline text
export LESS_TERMCAP_se=$'\e[0m'           # end of statusline text
export LESS_TERMCAP_us=$'\e[04;38;5;146m' # start of underlined text
export LESS_TERMCAP_ue=$'\e[0m'           # end of underlined text

if [ -f /proc/cpuinfo ]; then
	export NUMCPUCORES="$(nproc)"
fi

if [ -z "$LOCALPROFILEREAD" ]; then
	export PATH="$HOME/bin:/x/bin:$PATH"
	export BUILD_ROOT=/x/build
	export GOPATH=/x
	export GOBIN=/x/bin

	if [ -d $HOME/perl5 ]; then
		eval $(perl -I ~/perl5/lib/perl5/ -Mlocal::lib)
	fi
	if [ -d $HOME/.rbenv ]; then
		export PATH="$HOME/.rbenv/bin:$PATH"
	fi
fi

# fix styling of KDE apps under non-KDE desktop (e.g. Sway)
if [ "${XDG_CURRENT_DESKTOP}" != KDE -a "${XDG_CURRENT_DESKTOP}" != GNOME ]; then
	export QT_QPA_PLATFORMTHEME="qt5ct"
fi

# aliases
alias less='less -R'            # recognise color characters
if hash mpc &>/dev/null; then
	alias m=mpc
	alias mi='mpc idle player; mpc'
fi
if hash ncmpcpp &>/dev/null; then
	alias ncmpc=ncmpcpp
fi
if [ "$(uname)" = "Linux" ]; then
	alias ls='ls --color=auto'
fi
if [ -f /usr/bin/steam ]; then
	alias steam="nice -n10 /usr/bin/steam"
fi
if [ -f /usr/bin/steam-native ]; then
	alias steam-native="nice -n10 /usr/bin/steam-native"
fi
if grep ID=arch /etc/os-release &>/dev/null; then
	alias p=pacman-wrapper
fi
if hash pwget &>/dev/null; then
	pwcopy() {
		if [ "${WAYLAND_DISPLAY}" != "" ]; then
			pwget "$@" | wl-copy --type text/plain --paste-once --trim-newline
		else
			pwget "$@" | xsel -bi
		fi
	}
fi
if hash pwget2 &>/dev/null; then
	pwcopy2() {
		if [ "${WAYLAND_DISPLAY}" != "" ]; then
			pwget2 "$@" | wl-copy --type text/plain --paste-once --trim-newline
		else
			pwget2 "$@" | xsel -bi
		fi
	}
fi
if hash units &>/dev/null; then
	alias units="units --verbose -o %.25g"
fi
if hash pinfo &>/dev/null; then
	alias info=pinfo
fi
if hash makepkg &>/dev/null; then
	mksrcinfo() {
		makepkg --printsrcinfo > .SRCINFO
	}
fi
cg() {
	local REPO_PATH="$(rtree get "$1")"
	[ $? -eq 0 ] && cd "${REPO_PATH}"
}

if hash rg &>/dev/null; then
	rg() {
		if [ -t 1 ]; then
			command rg -p "$@" | less -RFX
		else
			command rg "$@"
		fi
	}
fi

forever() {
	while true; do
		"$@"
		sleep 0.1 # to make ^C work correctly if "$@" does not handle it correctly
	done
}

if hash mpv &>/dev/null; then
	mpv() {
		if [ $# -eq 0 ]; then
			if [ "${WAYLAND_DISPLAY}" != "" ]; then
				env mpv "$(wl-paste --type text/plain)"
			else
				env mpv "$(xsel -b)"
			fi
		else
			env mpv "$@"
		fi
	}
	zdf() {
		env mpv https://www.zdf.de/sender/zdf/zdf-live-beitrag-100.html
	}
	zdfinfo() {
		env mpv https://www.zdf.de/dokumentation/zdfinfo-doku/zdfinfo-live-beitrag-100.html
	}
	phoenix() {
		env mpv https://www.zdf.de/sender/phoenix/phoenix-live-beitrag-100.html
	}
fi

if hash youtube-dl &>/dev/null; then
	youtube-dl() {
		if [ $# -eq 0 ]; then
			if [ "${WAYLAND_DISPLAY}" != "" ]; then
				env youtube-dl -f best "$(wl-paste --type text/plain)"
			else
				env youtube-dl -f best "$(xsel -b)"
			fi
		else
			env youtube-dl "$@"
		fi
	}
fi

if hash nix-build &>/dev/null; then
	nb() {
		if [ $# -eq 1 ]; then
			nix-build -E "with (import <nixpkgs> {}); callPackage $1 {}"
		else
			echo "usage: nb <derivation-source-file>" >&2
			return 1
		fi
	}
fi

if hash monastery &>/dev/null; then
	mo() {
		if [ $# -eq 1 ]; then
			monastery "/x/src/git.bethselamin.de/stefan/secrets/monastery/$1.json"
		else
			echo "usage: mo <playbook-name>" >&2
			return 1
		fi
	}
fi

# for OpenStack
if hash cloud &>/dev/null; then
	cloud_is() {
		unset $(env | grep '^OS_' | cut -d= -f1) CURRENT_OS_CLOUD
		eval "$(/x/bin/cloud "$@"; echo "EXIT_CODE=$?")"
		if [ "$EXIT_CODE" = 0 ]; then
			env | grep '^OS_' | sed '/^OS_PASSWORD=/s/=.*/=<hidden>/' | sort
			if [ -z "$OS_PASSWORD" ]; then
				echo -n "OS_PASSWORD="
				read -s OS_PASSWORD && export OS_PASSWORD
				if [ -n "$OS_PASSWORD" ]; then
					echo "<hidden>"
				else
					echo "<not set>"
				fi
			fi
		fi
	}
fi

# for Ruby
if [ -d $HOME/.rbenv ]; then
	eval "$(rbenv init -)"
fi
if hash foreman &>/dev/null; then
	foreman() {
		[ -f .procfile ] && env foreman "$@" -f .procfile || env foreman "$@"
	}
fi

if hash kubectl &>/dev/null; then
	kc() {
		case $# in
			1)
				kubectl config use-context "$1"
				echo "" > ~/.kubectl-namespace
				;;
			2)
				kubectl config use-context "$1"
				echo "$2" > ~/.kubectl-namespace
				;;
			*)
				echo "usage: kc <context> [namespace]" >&2
				return 1
				;;
		esac
	}

	kn() {
		case $# in
			0)
				echo "" > ~/.kubectl-namespace
				;;
			1)
				echo "$1" > ~/.kubectl-namespace
				;;
			*)
				echo "usage: kn [namespace]" >&2
				return 1
				;;
		esac
	}

	k() {
		local KUBECTL
		local KUBECTL_NAMESPACE="$(cat ~/.kubectl-namespace)"
		if [ "${KUBECTL_NAMESPACE}" != "" ]; then
			KUBECTL=(kubectl --namespace="$KUBECTL_NAMESPACE")
		else
			KUBECTL=kubectl
		fi

		case "$1" in
		sh)
			shift
			${KUBECTL} exec -ti "$@" -- env COLUMNS=$COLUMNS LINES=$LINES TERM=$TERM /bin/sh
			;;
		bash)
			shift
			${KUBECTL} exec -ti "$@" -- env COLUMNS=$COLUMNS LINES=$LINES TERM=$TERM /bin/bash
			;;
		yaml)
			shift
			${KUBECTL} get "$@" -o yaml
			;;
		*)
			${KUBECTL} "$@"
			;;
		esac
	}

	if hash helm &>/dev/null; then
		# Synopsis: h <upgrade|diff> [chart-directory] [options]
		#
		# Call `helm upgrade` or `helm diff` on the chart in that directory, using the appropriate
		# values.yaml from $HELM_SECRETS_REPO. If no directory is given, use the working directory.
		# Any additional options are passed on to "helm upgrade".
		h() {
			(
				local COMMAND="$1"
				shift

				case "${1:-empty}" in
					-*|empty)
						;;
					*)
						cd "$1"
						shift
						;;
				esac
				if [ ! -f Chart.yaml ]; then
					echo "Chart.yaml: file not found" >&2
					return 1
				fi
				if [ -z "${HELM_SECRETS_REPO}" ]; then
					echo "\$HELM_SECRETS_REPO not set!" >&2
					return 1
				fi

				git -C "${HELM_SECRETS_REPO}" pull | grep -v 'master is up to date'

				CHART_NAME="$(awk '/name:/{print$2}' Chart.yaml)"
				CONTEXT_NAME="$(kubectl config current-context)"
				VALUES_FILE="$(find "${HELM_SECRETS_REPO}/${CONTEXT_NAME}/values" -name "${CHART_NAME}.yaml" | head -n1)"
				if [ ! -f "${VALUES_FILE}" ]; then
					echo "no values.yaml found for ${CHART_NAME} in ${CONTEXT_NAME}" >&2
					return 1
				fi
				GLOBALS_FILE="${HELM_SECRETS_REPO}/${CONTEXT_NAME}/values/globals.yaml"
				if [ ! -f "${GLOBALS_FILE}" ]; then
					echo "no globals.yaml found in ${CONTEXT_NAME}" >&2
					return 1
				fi

				if [ "${CONTEXT_NAME}" != staging -a "${CONTEXT_NAME}" != qa-de-1 -a "${COMMAND}" = upgrade -a "${I_KNOW_THIS_IS_PROD:-}" != yes ]; then
					echo "Not upgrading a productive region without I_KNOW_THIS_IS_PROD=yes." >&2
					return 1
				fi

				EXTRA_ARGS=()
				GLOBAL_VALUES_FILE="$(find "${HELM_SECRETS_REPO}/global/values" -name "${CHART_NAME}.yaml" | head -n1)"
				if [ -f "${GLOBAL_VALUES_FILE}" ]; then
					EXTRA_ARGS+=(--values "${GLOBAL_VALUES_FILE}")
				fi
				if [ "${COMMAND}" = upgrade ]; then
					EXTRA_ARGS+=(--reset-values)
				fi

				FIRST_ARG="${CHART_NAME}"
				if [ "${COMMAND}" = install -o "${COMMAND}" = template ]; then
					FIRST_ARG=""
				fi

				(
					set -x
					helm "${COMMAND}" ${FIRST_ARG} --values "${GLOBALS_FILE}" --values "${VALUES_FILE}" "${EXTRA_ARGS[@]}" "$@" .
				)
			)
		}
	fi
fi

# this must always be at the end
export LOCALPROFILEREAD="yes"
