HISTFILE=~/.histfile
HISTSIZE=100000
SAVEHIST=100000
PROMPT="\$($HOME/bin/prettyprompt)"
export PRETTYPROMPT_SHELL="zsh"
setopt autocd noautoparamslash autopushd nobeep nobgnice correct extendedglob noflowcontrol globdots histexpiredupsfirst histignoredups nohup incappendhistory longlistjobs nopromptcr promptsubst pushdminus pushdsilent pushdtohome rcquotes recexact
#setopt appendhistory autocd correct extendedglob histignoredups incappendhistory noflowcontrol nomatch notify promptsubst
unsetopt beep
bindkey -e

test -z "$LOCALPROFILEREAD" && source ~/.profile || true
test -s ~/.profile.local && . ~/.profile.local || true

FPATH="$FPATH:$HOME/.zsh-functions"
autoload compinit
compinit
# The following lines were added by compinstall
#zstyle :compinstall filename '/home/stefan/.zshrc'
# End of lines added by compinstall

# Keybindings f端r Sondertasten
bindkey "^[[2~" yank                    # Insert
bindkey "^[[3~" delete-char             # Del
bindkey "^[[5~" up-line-or-history      # PageUp
bindkey "^[[6~" down-line-or-history    # PageDown
bindkey "^E"    expand-cmd-path         # C-e for expanding path of typed command.
bindkey "^[[A"  up-line-or-search       # Up arrow for back-history-search.
bindkey "^[[B"  down-line-or-search     # Down arrow for fwd-history-search.
bindkey " "     magic-space             # Do history expansion on space.
case "$TERM" in
        linux|screen)
                bindkey "^[[1~" beginning-of-line       # Pos1
                bindkey "^[[4~" end-of-line             # End
        ;;
        *xterm*|(dt|k)term)
                bindkey "^[[H"  beginning-of-line       # Pos1
                bindkey "^[[F"  end-of-line             # End
                bindkey "^[[7~" beginning-of-line       # Pos1
                bindkey "^[[8~" end-of-line             # End
        ;;
        rxvt|Eterm)
                bindkey "^[[7~" beginning-of-line       # Pos1
                bindkey "^[[8~" end-of-line             # End
        ;;
esac

# Aliase f端r schnellere Verzeichnisnavigation
# alias -g ...='../..'
# alias -g ....='../../..'
# alias -g .....='../../../..'
# Alias f端r Detached Launching
alias -g "\&"="&>/dev/null&|"
# Aliase f端r Git-Zugriff aus ~/.gitconfig erstellen
while read git_line; do
	if echo $git_line | grep '^\[.*\]$' &>/dev/null; then
		git_category=$git_line
	else
		echo $git_category $git_line
	fi
done < $HOME/.gitconfig | grep '^\[alias\]' | cut -d' ' -f2- | sed 's/ = / /' | while read git_alias git_command; do
	alias $git_alias="git $git_alias"
done
unset git_line git_category git_alias git_command

# taken from http://zshwiki.org/home/zle/bindkeys
# by default: export WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>'
# we take out the slash, period, angle brackets, dash here.
# EDIT: also the equality sign, to have an intermediate break point in "--system=threedisks"
export WORDCHARS='*?_[]~&;!#$%^(){}'

# helper functions for KDE development
# idea from http://techbase.kde.org/Getting_Started/Increased_Productivity_in_KDE4_with_Scripts/.bashrc

export BUILD_ROOT="$HOME/tmp/build" # the equivalent to $HOME, for build directories

function find_direct_build_dir() { # argument: path to directory
	# go inside build hierarchy if not in it already
	if [ "$(relpath "$BUILD_ROOT" "$1" | head -c2)" = ".." ]; then
		echo -n "$BUILD_ROOT"
	fi
	abspath "$1"
}

function find_direct_source_dir() { # argument: path to directory
	if [ "$(relpath "$BUILD_ROOT" "$1" | head -c2)" = "./" ]; then
		echo "$1" | sed "s,^$BUILD_ROOT,,"
	else
		echo "$1"
	fi
}

function find_build_dir() { # argument: path to directory, check file name (if given, search will automatically ascend in directory hierarchy as long as that file exists there)
	#TODO: stub
	find_direct_build_dir "$1"
}

function chpwd() { # no arguments (hook; is called by cd)
	export B="$(find_direct_build_dir "$(pwd)")"
	export S="$(find_direct_source_dir "$(pwd)")"
}
chpwd # initialize $B and $S

function cb() { # no arguments
	cd $B
}

function cs() { # no arguments
	cd $S
}

function cmk() { # all arguments are passed to cmake
	mkdir -p $B || ( echo "Failed to create $B"; return 1 )
	cd $B
	if [ ! -f CMakeCache.txt -a -f $S/CMakeLists.txt ]; then
		cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo $@ $S || ( cd $S; return 1 )
	elif [ $# -gt 0 ]; then
		cmake $@ . || ( cd $S; return 1 )
	fi
	make -j3 || ( cd $S; return 1 )
	cd $S
}

function cmki() { # all arguments are passed to cmake
	cmk $@ || return 1
	cd $B || ( echo "Directory $B does not exist"; return 1 )
	sudo make install/fast -j3 || ( cd $S; return 1 )
	# TODO: fallback to "make install" if install/fast target is not available
	cd $S
}

function cmku() {
	cd $B || ( echo "Directory $BUILD_DIR does not exist"; return 1 )
	sudo make uninstall || ( cd $S; return 1 )
	# TODO: fallback to "xargs sudo rm < install_manifest.txt"
	cd $S
}

function qmk() { # all arguments are passed to qmake
	mkdir -p $B || ( echo "Failed to create $B"; return 1 )
	cd $B
	if [ ! -f Makefile -a -f $S/*.pro ]; then
		qmake $@ $S || ( cd $S; return 1 )
	elif [ $# -gt 0 ]; then
		qmake $@ $S || ( cd $S; return 1 )
	fi
	make -j3 || ( cd $S; return 1 )
	cd $S
}

function mk() { # all arguments are passed to make
	if lamake show root &> /dev/null; then
		if lamake; then; else return 1; fi
		if [ ! -d $B ]; then return 0; fi
	fi
	cd $B || return 1
	[ -f Makefile ] || ( echo "Error: No Makefile present."; cd $S; return 1 )
	make -j3 $@ || ( cd $S; return 1 )
	cd $S
}

# key bindings
bindkey '^Z' undo

function psgrep() { # all arguments passed to grep
	ps aux | grep $* | grep -v grep
}

rationalise-dot() {
	if [[ $LBUFFER = *.. ]]; then
		LBUFFER+=/..
	else
		LBUFFER+=.
	fi
}
zle -N rationalise-dot
bindkey . rationalise-dot
